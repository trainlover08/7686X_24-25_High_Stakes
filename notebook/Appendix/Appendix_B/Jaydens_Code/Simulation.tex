\appendix
\important{Jayden's Simulation Code (Updated: October 29th, 2024)}
\chapterauthor{author: Jayden Yanzick \\ formatted by: Caleb Bachmeier}
\info{Simulation Code}{Jayden Yanzick}{Updated: October 29th, 2024}
\section*{Robot Controller Libraries}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/robot_controller/include/libraries.h)

// WEBOTS
// webots libraries
#include <webots/Camera.hpp>
#include <webots/Emitter.hpp>
#include <webots/GPS.hpp>
#include <webots/Motor.hpp>
#include <webots/Node.hpp>
#include <webots/Receiver.hpp>
#include <webots/Supervisor.hpp>

#define TIME_STEP 64

// webots namespace
using namespace webots;

// OTHER
// extra libraries
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <utility>
#include <cstring>
#include <deque>
#include <random>
#include <tuple>
#include <cmath>
#include <fstream>
#include <stdexcept>
#include <cassert>

// extra namespaces
using namespace std;
\end{minted}
\section*{Robot Controller Devices}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/robot_controller/include/devices.h)
 
#include "include/libraries.h"
// main robot
Supervisor *robot = new Supervisor();
 
// drivetrain motors
Motor *left1 = robot->getMotor("left1");
Motor *left2 = robot->getMotor("left2");
Motor *left3 = robot->getMotor("left3");
Motor *right1 = robot->getMotor("right1");
Motor *right2 = robot->getMotor("right2");
Motor *right3 = robot->getMotor("right3");
 
// other motors/pneumatics
Motor *Hook = robot->getMotor("hookPneumatic");
Motor *topRingArm = robot->getMotor("topRingArm");
Motor *intakeHold = robot->getMotor("intakeHold");
Motor *intakeRoll = robot->getMotor("intakeRoll");
Motor *conveyor = robot->getMotor("conveyor");
Motor *ringClampL = robot->getMotor("ringClampL");
Motor *ringClampR = robot->getMotor("ringClampR");
 
// other deivces
Emitter *emit = robot->getEmitter("emit");
Receiver *receiv = robot->getReceiver("receiv");
Camera *invisVision = robot->getCamera("invisVision");
GPS *yes = robot->getGPS("yes");
 
// nodes
// robot and goals
Node *mainBotNode = robot->getFromDef("mainBot");
Node *goalNode1 = robot->getFromDef("goal1");
Node *goalNode2 = robot->getFromDef("goal2");
Node *goalNode3 = robot->getFromDef("goal3");
Node *goalNode4 = robot->getFromDef("goal4");
Node *goalNode5 = robot->getFromDef("goal5");
 
// rings
// red rings
Node *redRing1 = robot->getFromDef("redRing1");
Node *redRing2 = robot->getFromDef("redRing2");
Node *redRing3 = robot->getFromDef("redRing3");
Node *redRing4 = robot->getFromDef("redRing4");
Node *redRing5 = robot->getFromDef("redRing5");
Node *redRing6 = robot->getFromDef("redRing6");
Node *redRing7 = robot->getFromDef("redRing7");
Node *redRing8 = robot->getFromDef("redRing8");
Node *redRing9 = robot->getFromDef("redRing9");
Node *redRing10 = robot->getFromDef("redRing10");
Node *redRing11 = robot->getFromDef("redRing11");
Node *redRing12 = robot->getFromDef("redRing12");
Node *redRing13 = robot->getFromDef("redRing13");
Node *redRing14 = robot->getFromDef("redRing14");
Node *redRing15 = robot->getFromDef("redRing15");
Node *redRing16 = robot->getFromDef("redRing16");
Node *redRing17 = robot->getFromDef("redRing17");
Node *redRing18 = robot->getFromDef("redRing18");
Node *redRing19 = robot->getFromDef("redRing19");
Node *redRing20 = robot->getFromDef("redRing20");
Node *redRing21 = robot->getFromDef("redRing21");
Node *redRing22 = robot->getFromDef("redRing22");
Node *redRing23 = robot->getFromDef("redRing23");
 
// blue rings
Node *blueRing1 = robot->getFromDef("blueRing1");
Node *blueRing2 = robot->getFromDef("blueRing2");
Node *blueRing3 = robot->getFromDef("blueRing3");
Node *blueRing4 = robot->getFromDef("blueRing4");
Node *blueRing5 = robot->getFromDef("blueRing5");
Node *blueRing6 = robot->getFromDef("blueRing6");
Node *blueRing7 = robot->getFromDef("blueRing7");
Node *blueRing8 = robot->getFromDef("blueRing8");
Node *blueRing9 = robot->getFromDef("blueRing9");
Node *blueRing10 = robot->getFromDef("blueRing10");
 
// fields
// robot and goals
Field *translateFieldBot = mainBotNode->getField("translation");
Field *rotateFieldBot = mainBotNode->getField("rotation");
Field *translateGoal1 = goalNode1->getField("translation");
Field *translateGoal2 = goalNode2->getField("translation");
Field *translateGoal3 = goalNode3->getField("translation");
Field *translateGoal4 = goalNode4->getField("translation");
Field *translateGoal5 = goalNode5->getField("translation");
 
// rings
// red rings
Field *translateRedRing1 = redRing1->getField("translation");
Field *translateRedRing2 = redRing2->getField("translation");
Field *translateRedRing3 = redRing3->getField("translation");
Field *translateRedRing4 = redRing4->getField("translation");
Field *translateRedRing5 = redRing5->getField("translation");
Field *translateRedRing6 = redRing6->getField("translation");
Field *translateRedRing7 = redRing7->getField("translation");
Field *translateRedRing8 = redRing8->getField("translation");
Field *translateRedRing9 = redRing9->getField("translation");
Field *translateRedRing10 = redRing10->getField("translation");
Field *translateRedRing11 = redRing11->getField("translation");
Field *translateRedRing12 = redRing12->getField("translation");
Field *translateRedRing13 = redRing13->getField("translation");
Field *translateRedRing14 = redRing14->getField("translation");
Field *translateRedRing15 = redRing15->getField("translation");
Field *translateRedRing16 = redRing16->getField("translation");
Field *translateRedRing17 = redRing17->getField("translation");
Field *translateRedRing18 = redRing18->getField("translation");
Field *translateRedRing19 = redRing19->getField("translation");
Field *translateRedRing20 = redRing20->getField("translation");
Field *translateRedRing21 = redRing21->getField("translation");
Field *translateRedRing22 = redRing22->getField("translation");
Field *translateRedRing23 = redRing23->getField("translation");
 
// blue rings
Field *translateBlueRing1 = blueRing1->getField("translation");
Field *translateBlueRing2 = blueRing2->getField("translation");
Field *translateBlueRing3 = blueRing3->getField("translation");
Field *translateBlueRing4 = blueRing4->getField("translation");
Field *translateBlueRing5 = blueRing5->getField("translation");
Field *translateBlueRing6 = blueRing6->getField("translation");
Field *translateBlueRing7 = blueRing7->getField("translation");
Field *translateBlueRing8 = blueRing8->getField("translation");
Field *translateBlueRing9 = blueRing9->getField("translation");
Field *translateBlueRing10 = blueRing10->getField("translation");
\end{minted}

\section*{Robot Controller Reset Functions}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/robot_controller/include/resetFunctions.cpp)
 
#include "include/libraries.h"
 
#define BLUEZ1 0.0705
#define BLUEZ2 0.094
#define REDZ 0.042
#define YELLOWZ 0.194
 
class Reset{
private:
  // id's for red rings #1
  void translateRingPosition1(int ID_, const double translate[3]) {
    switch (ID_) {
      case 1:
        translateRedRing1->setSFVec3f(translate);
      break;
      case 2:
        translateRedRing2->setSFVec3f(translate);
      break;
      case 3:
        translateRedRing3->setSFVec3f(translate);
      break;
      case 4:
        translateRedRing4->setSFVec3f(translate);
      break;
      case 5:
        translateRedRing5->setSFVec3f(translate);
      break;
      case 6:
        translateRedRing6->setSFVec3f(translate);
      break;
      case 7:
        translateRedRing7->setSFVec3f(translate);
      break;
      case 8:
        translateRedRing8->setSFVec3f(translate);
      break;
      case 9:
        translateRedRing9->setSFVec3f(translate);
      break;
      case 10:
        translateRedRing10->setSFVec3f(translate);
      break;
      case 11:
        translateRedRing11->setSFVec3f(translate);
      break;
      case 12:
        translateRedRing12->setSFVec3f(translate);
      break;
    }
  }
 
  // id's for red rigns #2
  void translateRingPosition2(int ID_, const double translate[3]) {
    switch (ID_) {
      case 13:
        translateRedRing13->setSFVec3f(translate);
      break;
      case 14:
        translateRedRing14->setSFVec3f(translate);
      break;
      case 15:
        translateRedRing15->setSFVec3f(translate);
      break;
      case 16:
        translateRedRing16->setSFVec3f(translate);
      break;
      case 17:
        translateRedRing17->setSFVec3f(translate);
      break;
      case 18:
        translateRedRing18->setSFVec3f(translate);
      break;
      case 19:
        translateRedRing19->setSFVec3f(translate);
      break;
      case 20:
        translateRedRing20->setSFVec3f(translate);
      break;
      case 21:
        translateRedRing21->setSFVec3f(translate);
      break;
      case 22:
        translateRedRing22->setSFVec3f(translate);
      break;
      case 23:
        translateRedRing23->setSFVec3f(translate);
      break;
    }
  }
 
  // reset the red rings
  void specificRed(int ID, float x, float y, float z) {
    const double translateRedRing[3] = {x, y, z};
    if (ID >= 13) {
      translateRingPosition2(ID, translateRedRing);
    } else {
      translateRingPosition1(ID, translateRedRing);
    }
  }
 
  // reset the blue rings
  void specificBlue(int ID, float x, float y, float z) {
    const double translateBlueRing[3] = {x, y, z};
    switch (ID) {
      case 1:
        translateBlueRing1->setSFVec3f(translateBlueRing);
      break;
      case 2:
        translateBlueRing2->setSFVec3f(translateBlueRing);
      break;
      case 3:
        translateBlueRing3->setSFVec3f(translateBlueRing);
      break;
      case 4:
        translateBlueRing4->setSFVec3f(translateBlueRing);
      break;
      case 5:
        translateBlueRing5->setSFVec3f(translateBlueRing);
      break;
      case 6:
        translateBlueRing6->setSFVec3f(translateBlueRing);
      break;
      case 7:
        translateBlueRing7->setSFVec3f(translateBlueRing);
      break;
      case 8:
        translateBlueRing8->setSFVec3f(translateBlueRing);
      break;
      case 9:
        translateBlueRing9->setSFVec3f(translateBlueRing);
      break;
      case 10:
        translateBlueRing10->setSFVec3f(translateBlueRing);
      break;
    }
  }
 
  // reset the yellow goals
  void specificYellow(int ID, float x, float y, float z) {
    const double translateGoal[3] = {x, y, z};
    switch (ID) {
      case 1:
        translateGoal1->setSFVec3f(translateGoal);
      break;
      case 2:
        translateGoal2->setSFVec3f(translateGoal);
      break;
      case 3:
        translateGoal3->setSFVec3f(translateGoal);
      break;
      case 4:
        translateGoal4->setSFVec3f(translateGoal);
      break;
      case 5:
        translateGoal5->setSFVec3f(translateGoal);
      break;
    }
  }
 
public:
  void resetBot(float x, float y, float z, float x1, float y1, float z1, float rad) {
    const double translateBot[3] = {x, y, z};
    const double rotateBot[4] = {x1, y1, z1, rad};
    translateFieldBot->setSFVec3f(translateBot);
    rotateFieldBot->setSFVec3f(rotateBot);
  }
 
  void resetRed() {
    specificRed(1, 0, 0, REDZ);
    specificRed(2, -1.2, 0, REDZ);
    specificRed(3, -1.2, -0.6, REDZ);
    specificRed(4, -0.6, -0.6, REDZ);
    specificRed(5, 0.6, -0.6, REDZ);
    specificRed(6, 1.2, -0.6, REDZ);
    specificRed(7, 1.2, 0, REDZ);
    specificRed(8, 1.2, 0.6, REDZ);
    specificRed(9, 0.6, 0.6, REDZ);
    specificRed(10, -0.6, 0.6, REDZ);
    specificRed(11, -1.2, 0.6, REDZ);
    specificRed(12, -1.5, 1.2, REDZ);
    specificRed(13, -1.2, 1.2, REDZ);
    specificRed(14, -1.2, 1.5, REDZ);
    specificRed(15, 1.2, 1.5, REDZ);
    specificRed(16, 1.2, 1.2, REDZ);
    specificRed(17, 1.5, 1.2, REDZ);
    specificRed(18, 1.5, -1.2, REDZ);
    specificRed(19, 1.2, -1.2, REDZ);
    specificRed(20, 1.2, -1.5, REDZ);
    specificRed(21, -1.2, -1.5, REDZ);
    specificRed(22, -1.2, -1.2, REDZ);
    specificRed(23, -1.5, -1.2, REDZ);
  }
 
  void resetBlue() {
    specificBlue(1, 0.6, -1.5, BLUEZ1);
    specificBlue(2, -0.6, -1.5, BLUEZ1);
    specificBlue(3, -1.2, -1.5, BLUEZ2);
    specificBlue(4, -1.2, -1.2, BLUEZ2);
    specificBlue(5, -1.5, -1.2, BLUEZ2);
    specificBlue(6, -1.69, -1.69, REDZ);
    specificBlue(7, 1.69, -1.69, REDZ);
    specificBlue(8, 1.5, -1.2, BLUEZ2);
    specificBlue(9, 1.2, -1.2, BLUEZ2);
    specificBlue(10, 1.2, -1.5, BLUEZ2);
  }
 
  void resetYellow() {
    specificYellow(1, 0, -1.18, YELLOWZ);
    specificYellow(2, 0.6, -1.49, YELLOWZ);
    specificYellow(3, 0.6, 1.18, YELLOWZ);
    specificYellow(4, -0.6, 1.18, YELLOWZ);
    specificYellow(5, -0.6, -1.49, YELLOWZ);
  }
};
\end{minted}
\section*{Robot Controller Robot Functions}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/robot_controller/include/robotFunctions.cpp)
 
// library for sim functions
#include "include/simFunctions.cpp"
 
// create the sim class
Sim sim;
 
class Bot{
private:
  double currentScore;
  bool training = true;
  int currentTerm = 25;
  int previousTerm = 0;
  bool E_NEW_NET = true;
public:
  const void* message = " ";
  double functionOutput;
 
  // activate or deactivate the hook
  void hook(bool activated) {
    if (activated == true) {
      Hook->setPosition(0.2);
    } else {
      Hook->setPosition(0);
    }
  }
 
  void topArm(bool activated) {
    if (activated == true) {
      topRingArm->setPosition(-1.2);
    } else {
      topRingArm->setPosition(0);
    }
  }
 
  void holder(bool activated) {
    if (activated == true) {
      intakeHold->setPosition(-0.5);
    } else {
      intakeHold->setPosition(0);
    }
  }
 
  void clamp(bool activated) {
    if (activated == true) {
      ringClampL->setPosition(0.3);
      ringClampR->setPosition(0.3);
    } else {
      ringClampL->setPosition(-0.3);
      ringClampR->setPosition(-0.3);
    }
  }
 
  void intake(bool spinning) {
    if (spinning == true) {
      intakeRoll->setVelocity(-100.0);
    } else {
      intakeRoll->setVelocity(0);
    }
  }
 
  void Conveyor(bool spinning) {
    if (spinning == true) {
      conveyor->setVelocity(-10.0);
    } else {
      conveyor->setVelocity(0);
    }
  }
 
  // training functions for network
  void trainingNetwork(NeuralNetwork& actor, NeuralNetwork& critic, int numEpisodes, double gamma, double learningRate, double GRADIENT_CLASH_THRESHOLD, double weight_decay) {
    // initialize variables
    vector<double> state;
    double input1;
    double input2;
    double input3;
    int extraReward;
    int runCount;
 
    AdamWOptimizer actorOptimizer(learningRate, 0.9, 0.999, 0.01, weight_decay);
    AdamWOptimizer criticOptimizer(learningRate, 0.9, 0.999, 0.01, weight_decay);
 
    actor.add_layer(Layer(3, 128, "relu", actorOptimizer));
    actor.add_layer(Layer(128, 128, "relu", actorOptimizer));
    actor.add_layer(Layer(128, 1, "linear", actorOptimizer));
 
    critic.add_layer(Layer(3, 128, "relu", criticOptimizer));
    critic.add_layer(Layer(128, 128, "relu", criticOptimizer));
    critic.add_layer(Layer(128, 1, "linear", criticOptimizer));
 
    if(E_NEW_NET == 1) {
        // Save neural network to file
        actor.save("actor_network_params.txt");
        critic.save("critic_network_params.txt");
    }
 
    for (int episode = 0; episode <= numEpisodes; ++episode) {
      // Load neural network from file
      NeuralNetwork actorLoadedNN;
      NeuralNetwork criticLoadedNN;
      actorLoadedNN.load("actor_network_params.txt");
      criticLoadedNN.load("critic_network_params.txt");
 
      actor = actorLoadedNN;
      critic = criticLoadedNN;
 
      fstream AIshots("ai_rec.html");
 
      vector<vector<double>> states;
      vector<double> actions, rewards, logProbs, values;
 
      if (left1->getVelocity() != 0.0) {
        sim.moveBot(0);
        sim.delay(50, "msec");
      }
      sim.resetSimManual();
      sim.programSetup();
      robot->animationStartRecording("ai_rec.html");
      training = true;
      while (training == true) {
        runCount = runCount + 1;
 
        // average velocities, and insert into array
        input1 = (left1->getVelocity() + left2->getVelocity() + left3->getVelocity()) / 3;
        input2 = (right1->getVelocity() + right2->getVelocity() + right3->getVelocity()) / 3;
        input3 = currentScore;
 
        // erase the vector, and insert the array
        state.assign({input1, input2, input3});
        states.push_back(state);
 
        vector<vector<double>> actionProbs = actor.forward({state});
 
        vector<vector<double>> valueEstimates = critic.forward({state});
 
        values.push_back(valueEstimates[0][0]);        
 
        sim.delay(64, "msec");
 
        double action = actionProbs[0][0];
        logProbs.push_back(log(max(actionProbs[0][action], 1e-8)));
 
        if (action > 0) {
          functionOutput = action * 10;
        } else if (action < 0) {
          functionOutput = action * -10;
        }
 
        if (functionOutput > 1) {
          functionOutput = functionOutput / 30;
        }
 
        cout << "MAINBOT: functionOutput = " << functionOutput << endl;
        functionConvert(functionOutput);
 
        if (left1->getVelocity() >= 0.1) {
          extraReward = extraReward + 20;
        }
 
        if (left1->getAcceleration() >= 0.01) {
          extraReward = extraReward + 3;
        }
 
        if (invisVision->getRecognitionNumberOfObjects() > 0) {
          extraReward = extraReward + (invisVision->getRecognitionNumberOfObjects() * 3);
        }
 
        if (left1->getVelocity() >= 0 && right1->getVelocity() <= 0) {
          extraReward = extraReward + 15;
        } else if (left1->getVelocity() <= 0 && right1->getVelocity() >= 0) {
          extraReward = extraReward + 20;
        }
 
        if (topRingArm->getTargetPosition() > 0) {
          extraReward = extraReward + 10;
        }
 
        if (intakeHold->getTargetPosition() > 0) {
          extraReward = extraReward + 10;
        }
 
        if (yes->getSpeed() <= 0.05) {
          extraReward = extraReward / 3;
        }
 
        sim.receive();
        if (receiv->getQueueLength() >= 1) {
          message = receiv->getData();
          currentScore = *(double *)message;
          rewards.push_back(input1 + input2 + input3 + extraReward);
          receiv->nextPacket();
        }
 
        if (robot->getTime() >= currentTerm) {
          training = false;
          previousTerm = currentTerm;
          currentTerm = currentTerm + 25;
          extraReward = 0;
 
          actor.save("actor_network_params.txt");
          critic.save("critic_network_params.txt");
        }
      }
 
      vector<double> advantages;
    for (int t = 0; t < rewards.size(); ++t) {
      double td_target = rewards[t] + (t < rewards.size() - 1 ? gamma * values[t + 1] : 0.0);
      advantages.push_back(td_target - values[t]);
    }
 
    if (episode == numEpisodes) {
      robot->animationStopRecording();
    }
 
    double actorLoss = computeLoss(logProbs, advantages);
 
    double criticLoss = 0.0;
    for (size_t i = 0; i < rewards.size(); ++i) {
      double td_target = rewards[i] + (i < rewards.size() - 1 ? gamma * values[i + 1] : 0.0);
      criticLoss += pow(td_target - values[i], 2);
    }
    criticLoss = rewards.size();
 
    actor.backward({{actorLoss}}, GRADIENT_CLASH_THRESHOLD);
    actor.update_weights();
 
    critic.backward({{criticLoss}}, GRADIENT_CLASH_THRESHOLD);
    critic.update_weights();
    }
 
  }
 
  double computeLoss(const vector<double>& logProbs, const vector<double>& advantages) {
    double loss = -0.005;
    for (int i = 0; i < logProbs.size(); ++ i) {
      loss -= logProbs[i] * advantages[i];
    }
    return loss;
  }
 
  void functionConvert(double functionID) {
    if (functionID >= -0.1 && functionID <= 0.1) {
      sim.moveBot(0);
    } else if (functionID >= 0.1 && functionID <= 0.2) {
      sim.moveBot(1);
    } else if (functionID >= 0.2 && functionID <= 0.3) {
      sim.moveBot(2);
    } else if (functionID >= 0.3 && functionID <= 0.4) {
      sim.moveBot(3);
    } else if (functionID >= 0.4 && functionID <= 0.5) {
      sim.moveBot(4);
    } else {
      sim.moveBot(0);
    }
 
    if (functionID >= 0.5 && functionID <= 0.6) {
      hook(true);
    } else if (functionID >= 0.6 && functionID <= 0.7) {
      hook(false);
    } else if (functionID >= 0.7 && functionID <= 0.8) {
      topArm(true);
    } else if (functionID >= 0.8 && functionID <= 0.9) {
      topArm(false);
    }
  }
};
\end{minted}
\section*{Robot Controller - Robot Functions}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/robot_controller/include/robotFunctions.cpp)
 
// library for sim functions
#include "include/simFunctions.cpp"
 
// create the sim class
Sim sim;
 
class Bot{
private:
  double currentScore;
  bool training = true;
  int currentTerm = 25;
  int previousTerm = 0;
  bool E_NEW_NET = true;
public:
  const void* message = " ";
  double functionOutput;
 
  // activate or deactivate the hook
  void hook(bool activated) {
    if (activated == true) {
      Hook->setPosition(0.2);
    } else {
      Hook->setPosition(0);
    }
  }
 
  void topArm(bool activated) {
    if (activated == true) {
      topRingArm->setPosition(-1.2);
    } else {
      topRingArm->setPosition(0);
    }
  }
 
  void holder(bool activated) {
    if (activated == true) {
      intakeHold->setPosition(-0.5);
    } else {
      intakeHold->setPosition(0);
    }
  }
 
  void clamp(bool activated) {
    if (activated == true) {
      ringClampL->setPosition(0.3);
      ringClampR->setPosition(0.3);
    } else {
      ringClampL->setPosition(-0.3);
      ringClampR->setPosition(-0.3);
    }
  }
 
  void intake(bool spinning) {
    if (spinning == true) {
      intakeRoll->setVelocity(-100.0);
    } else {
      intakeRoll->setVelocity(0);
    }
  }
 
  void Conveyor(bool spinning) {
    if (spinning == true) {
      conveyor->setVelocity(-10.0);
    } else {
      conveyor->setVelocity(0);
    }
  }
 
  // training functions for network
  void trainingNetwork(NeuralNetwork& actor, NeuralNetwork& critic, int numEpisodes, double gamma, double learningRate, double GRADIENT_CLASH_THRESHOLD, double weight_decay) {
    // initialize variables
    vector<double> state;
    double input1;
    double input2;
    double input3;
    int extraReward;
    int runCount;
 
    AdamWOptimizer actorOptimizer(learningRate, 0.9, 0.999, 0.01, weight_decay);
    AdamWOptimizer criticOptimizer(learningRate, 0.9, 0.999, 0.01, weight_decay);
 
    actor.add_layer(Layer(3, 128, "relu", actorOptimizer));
    actor.add_layer(Layer(128, 128, "relu", actorOptimizer));
    actor.add_layer(Layer(128, 1, "linear", actorOptimizer));
 
    critic.add_layer(Layer(3, 128, "relu", criticOptimizer));
    critic.add_layer(Layer(128, 128, "relu", criticOptimizer));
    critic.add_layer(Layer(128, 1, "linear", criticOptimizer));
 
    if(E_NEW_NET == 1) {
        // Save neural network to file
        actor.save("actor_network_params.txt");
        critic.save("critic_network_params.txt");
    }
 
    for (int episode = 0; episode <= numEpisodes; ++episode) {
      // Load neural network from file
      NeuralNetwork actorLoadedNN;
      NeuralNetwork criticLoadedNN;
      actorLoadedNN.load("actor_network_params.txt");
      criticLoadedNN.load("critic_network_params.txt");
 
      actor = actorLoadedNN;
      critic = criticLoadedNN;
 
      fstream AIshots("ai_rec.html");
 
      vector<vector<double>> states;
      vector<double> actions, rewards, logProbs, values;
 
      if (left1->getVelocity() != 0.0) {
        sim.moveBot(0);
        sim.delay(50, "msec");
      }
      sim.resetSimManual();
      sim.programSetup();
      robot->animationStartRecording("ai_rec.html");
      training = true;
      while (training == true) {
        runCount = runCount + 1;
 
        // average velocities, and insert into array
        input1 = (left1->getVelocity() + left2->getVelocity() + left3->getVelocity()) / 3;
        input2 = (right1->getVelocity() + right2->getVelocity() + right3->getVelocity()) / 3;
        input3 = currentScore;
 
        // erase the vector, and insert the array
        state.assign({input1, input2, input3});
        states.push_back(state);
 
        vector<vector<double>> actionProbs = actor.forward({state});
 
        vector<vector<double>> valueEstimates = critic.forward({state});
 
        values.push_back(valueEstimates[0][0]);        
 
        sim.delay(64, "msec");
 
        double action = actionProbs[0][0];
        logProbs.push_back(log(max(actionProbs[0][action], 1e-8)));
 
        if (action > 0) {
          functionOutput = action * 10;
        } else if (action < 0) {
          functionOutput = action * -10;
        }
 
        if (functionOutput > 1) {
          functionOutput = functionOutput / 30;
        }
 
        cout << "MAINBOT: functionOutput = " << functionOutput << endl;
        functionConvert(functionOutput);
 
        if (left1->getVelocity() >= 0.1) {
          extraReward = extraReward + 20;
        }
 
        if (left1->getAcceleration() >= 0.01) {
          extraReward = extraReward + 3;
        }
 
        if (invisVision->getRecognitionNumberOfObjects() > 0) {
          extraReward = extraReward + (invisVision->getRecognitionNumberOfObjects() * 3);
        }
 
        if (left1->getVelocity() >= 0 && right1->getVelocity() <= 0) {
          extraReward = extraReward + 15;
        } else if (left1->getVelocity() <= 0 && right1->getVelocity() >= 0) {
          extraReward = extraReward + 20;
        }
 
        if (topRingArm->getTargetPosition() > 0) {
          extraReward = extraReward + 10;
        }
 
        if (intakeHold->getTargetPosition() > 0) {
          extraReward = extraReward + 10;
        }
 
        if (yes->getSpeed() <= 0.05) {
          extraReward = extraReward / 3;
        }
 
        sim.receive();
        if (receiv->getQueueLength() >= 1) {
          message = receiv->getData();
          currentScore = *(double *)message;
          rewards.push_back(input1 + input2 + input3 + extraReward);
          receiv->nextPacket();
        }
 
        if (robot->getTime() >= currentTerm) {
          training = false;
          previousTerm = currentTerm;
          currentTerm = currentTerm + 25;
          extraReward = 0;
 
          actor.save("actor_network_params.txt");
          critic.save("critic_network_params.txt");
        }
      }
 
      vector<double> advantages;
    for (int t = 0; t < rewards.size(); ++t) {
      double td_target = rewards[t] + (t < rewards.size() - 1 ? gamma * values[t + 1] : 0.0);
      advantages.push_back(td_target - values[t]);
    }
 
    if (episode == numEpisodes) {
      robot->animationStopRecording();
    }
 
    double actorLoss = computeLoss(logProbs, advantages);
 
    double criticLoss = 0.0;
    for (size_t i = 0; i < rewards.size(); ++i) {
      double td_target = rewards[i] + (i < rewards.size() - 1 ? gamma * values[i + 1] : 0.0);
      criticLoss += pow(td_target - values[i], 2);
    }
    criticLoss = rewards.size();
 
    actor.backward({{actorLoss}}, GRADIENT_CLASH_THRESHOLD);
    actor.update_weights();
 
    critic.backward({{criticLoss}}, GRADIENT_CLASH_THRESHOLD);
    critic.update_weights();
    }
 
  }
 
  double computeLoss(const vector<double>& logProbs, const vector<double>& advantages) {
    double loss = -0.005;
    for (int i = 0; i < logProbs.size(); ++ i) {
      loss -= logProbs[i] * advantages[i];
    }
    return loss;
  }
 
  void functionConvert(double functionID) {
    if (functionID >= -0.1 && functionID <= 0.1) {
      sim.moveBot(0);
    } else if (functionID >= 0.1 && functionID <= 0.2) {
      sim.moveBot(1);
    } else if (functionID >= 0.2 && functionID <= 0.3) {
      sim.moveBot(2);
    } else if (functionID >= 0.3 && functionID <= 0.4) {
      sim.moveBot(3);
    } else if (functionID >= 0.4 && functionID <= 0.5) {
      sim.moveBot(4);
    } else {
      sim.moveBot(0);
    }
 
    if (functionID >= 0.5 && functionID <= 0.6) {
      hook(true);
    } else if (functionID >= 0.6 && functionID <= 0.7) {
      hook(false);
    } else if (functionID >= 0.7 && functionID <= 0.8) {
      topArm(true);
    } else if (functionID >= 0.8 && functionID <= 0.9) {
      topArm(false);
    }
  }
};
\end{minted}
\section*{Robot Controller - Test}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/robot_controller/include/test.cpp)
 
#include "include/robotFunctions.cpp"
 
Bot bot;
 
class Test{
private:
 
public:
  int systemsTest() {
    int errorCode;
 
    /* error code list
 
      error 1: lifting upper arm failed
      error 2: lowering upper arm failed
      error 3: upper arm device not found
      error 4: intake holder activation failed
      error 5: intake holder deactivation failed
      error 6: intake holder device not found
      error 7: spinning intake failed
      error 8: stopping intake failed
      error 9: intake device not found
      error 10: ring clamp activation failed
      error 11: ring clamp deactivation failed
      error 12: ring clamp device(s) not found
      error 13: wing activation failed
      error 14: wing deactivation failed
      error 15: wing device not found
 
      conveyor stuff
 
      error 16: sending on emitter failed
      error 17: receiving on receiver failed
      error 18: emitter device not found
      error 19: receiver device not found
      error 20: hook activation failed
      error 21: hook deactivation failed
      error 22: hook device not found
      error 23: drive forward command failed
      error 24: drive backward command failed
      error 25: turn left command failed
      error 26: turn right command failed
      error 27: a left-drive device not found
      error 28: a right-drive device not found
 
    */
 
    cout << "MAINBOT: system test script start" << endl;
    errorCode = isTopArmGood();
    outputError(errorCode);
    errorCode = isHolderGood();
    outputError(errorCode);
    errorCode = isIntakeGood();
    outputError(errorCode);
    errorCode = isRingClampGood();
    outputError(errorCode);
    errorCode = isEmitterGood();
    outputError(errorCode);
    errorCode = isReceiverGood();
    outputError(errorCode);
    errorCode = isHookGood();
    outputError(errorCode);
    errorCode = isDrivetrainGood();
    outputError(errorCode);
    cout << "MAINBOT: system test script end, tests successful" << endl;
    sim.delay(1, "sec");
 
    return errorCode;
  }
 
  void outputError(int errorID) {
    if (errorID != NULL) {
      cout << "TESTER: warning: system fault, error code " << errorID << endl;
      sim.delay(9999, "sec");
    } else {
      sim.delay(1, "sec");
    }
  }
 
  int isTopArmGood() {
    int errorCode;
    if (robot->getFromDef("topRingArm") != NULL) {
      bot.topArm(true);
      cout << "TESTER: top arm activation signal sent" << endl;
      if (topRingArm->getAcceleration() > 0) {
        sim.delay(1, "sec");
        bot.topArm(false);
        cout << "TESTER: top arm deactivation signal sent" << endl;
        if (topRingArm->getAcceleration() > 0) {
          errorCode = NULL;
          sim.delay(1, "sec");
          cout << "TESTER: top arm is good" << endl;
        } else {
          errorCode = 2;
        }
      } else {
        errorCode = 1;
      }
    } else {
      errorCode = 3;
    }
 
    return errorCode;
  }
 
  int isHolderGood() {
    int errorCode;
    if (robot->getFromDef("intakeHold") != NULL) {
      bot.holder(true);
      cout << "TESTER: intake holder activation signal sent" << endl;
      if (intakeHold->getTargetPosition() < 0) {
        sim.delay(1, "sec");
        bot.holder(false);
        cout << "TESTER: intake holder deactivation signal sent" << endl;
        if (intakeHold->getTargetPosition() == 0) {
          errorCode = NULL;
          sim.delay(1, "sec");
          cout << "TESTER: intake holder is good" << endl;
        } else {
          errorCode = 5;
        }
      } else {
        errorCode = 4;
      }
    } else {
      errorCode = 6;
    }
 
    return errorCode;
  }
 
  int isIntakeGood() {
    int errorCode;
    if (robot->getFromDef("intakeRoll") != NULL) {
      bot.intake(true);
      cout << "TESTER: intake roller activation signal sent" << endl;
      if (intakeRoll->getAcceleration() > 0) {
        sim.delay(1, "sec");
        bot.intake(false);
        cout << "TESTER: intake roller deactivation signal sent" << endl;
        if (intakeRoll->getAcceleration() > 0) {
          errorCode = NULL;
          sim.delay(1, "sec");
          cout << "TESTER: intake roller is good" << endl;
        } else {
          errorCode = 8;
        }
      } else {
        errorCode = 7;
      }
    } else {
      errorCode = 9;
    }
 
    return errorCode;
  }
 
  int isRingClampGood() {
    int errorCode;
    if (robot->getFromDef("ringClampL") != NULL) {
      bot.clamp(true);
      cout << "TESTER: ring clamp activation signal sent" << endl;
      if (ringClampL->getAcceleration() > 0 && ringClampR->getAcceleration() > 0) {
        sim.delay(1, "sec");
        bot.clamp(false);
        cout << "TESTER: ring clamp deactivation signal sent" << endl;
        if (ringClampL->getAcceleration() > 0 && ringClampR->getAcceleration() > 0) {
          errorCode = NULL;
          sim.delay(1, "sec");
          cout << "TESTER: ring clamp is good" << endl;
        } else {
          errorCode = 11;
        }
      } else {
        errorCode = 10;
      }
    } else {
      errorCode = 12;
    }
 
    return errorCode;
  }
 
  int isWingGood() {
    int errorCode;
 
    return errorCode;
  }
 
  int isConveyorGood() {
    int errorCode;
    if (robot->getFromDef("conveyor") != NULL) {
      bot.Conveyor(true);
      cout << "TESTER: conveyor activation signal sent" << endl;
      if (conveyor->getAcceleration() > 0) {
        sim.delay(1, "sec");
        bot.Conveyor(false);
        cout << "TESTER: conveyor deactivation signal sent" << endl;
        if (conveyor->getAcceleration() > 0) {
          errorCode = NULL;
          sim.delay(1, "sec");
          cout << "TESTER: conveyor is good" << endl;
        } else {
          errorCode = 14;
        }
      } else {
        errorCode = 13;
      }
    } else {
      errorCode = 15;
    }
 
    return errorCode;
  }
 
  int isEmitterGood() {
    int errorCode;
    const char* yes = "systemTest";
    if (robot->getFromDef("emit") != NULL) {
      sim.sendMessage(yes, strlen(yes) + 1);
      cout << "TESTER: testing emitter" << endl;
      if (emit->getChannel() == 0) {
        errorCode = NULL;
        sim.delay(1, "sec");
        cout << "TESTER: emitter is good" << endl;
      } else {
        errorCode = 16;
      }
    } else {
      errorCode = 18;
    }
 
    return errorCode;
  }
 
  int isReceiverGood() {
    int errorCode;
    if (robot->getFromDef("receiv") != NULL) {
      sim.receive();
      cout << "TESTER: testing receiver" << endl;
      if (receiv->getQueueLength() > 0) {
        errorCode = NULL;
        sim.delay(1, "sec");
        cout << "TESTER: receiver is good" << endl;
      } else {
        errorCode = 17;
      }
    } else {
      errorCode = 19;
    }
 
    return errorCode;
  }
 
  int isHookGood() {
    int errorCode;
    if (robot->getFromDef("Hook") != NULL) {
      bot.hook(true);
      cout << "TESTER: clamp activation signal sent" << endl;
      if (Hook->getTargetPosition() > 0) {
        sim.delay(1, "sec");
        bot.hook(false);
        cout << "TESTER: clamp deactivation signal sent" << endl;
        if (Hook->getTargetPosition() == 0) {
          errorCode = NULL;
          sim.delay(1, "sec");
          cout << "TESTER: clamp is good" << endl;
        } else {
          errorCode = 21;
        }
      } else {
        errorCode = 20;
      }
    } else {
      errorCode = 22;
    }
 
    return errorCode;
  }
 
  int isDrivetrainGood() {
    int errorCode;
    if (robot->getFromDef("left1") != NULL && robot->getFromDef("left2") != NULL && robot->getFromDef("left3") != NULL) {
      if (robot->getFromDef("right1") != NULL && robot->getFromDef("right2") != NULL && robot->getFromDef("right3") != NULL) {
        sim.moveBot(1);
        cout << "TESTER: drivetrain forward command sent" << endl;
        if (left1->getAcceleration() > 0 && right1->getAcceleration() > 0) {
          sim.delay(1, "sec");
          sim.moveBot(2);
          cout << "TESTER: drivetrain reverse command sent" << endl;
          sim.delay(50, "msec");
          if (left1->getAcceleration() > 0 && right1->getAcceleration() > 0) {
            sim.delay(1, "sec");
            sim.moveBot(3);
            cout << "TESTER: drivetrain left command sent" << endl;
            sim.delay(50, "msec");
            if (left1->getAcceleration() > 0) {
              sim.delay(1, "sec");
              sim.moveBot(4);
              cout << "TESTER: drivetrain right command sent" << endl;
              sim.delay(50, "msec");
              if (right1->getAcceleration() > 0) {
                errorCode = NULL;
                sim.delay(1, "sec");
                cout << "TESTER: drivetrain is good" << endl;
                sim.moveBot(0);
              } else {
                errorCode = 26;
              }
            } else {
              errorCode = 25;
            }
          } else {
            errorCode = 24;
          }
        } else {
          errorCode = 23;
        }
      } else {
        errorCode = 28;
      }
    } else {
      errorCode = 27;
    }
 
    return errorCode;
  }
};
\end{minted}
\section*{Robot Controller - Robot Controller}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/robot_controller/robot_controller.cpp)
 
#include "include/devices.h"
#include "include/test.cpp"
 
int main() {
  cout << "program has started" << endl;
  string test = "testing";
  // SETUP
  Test t;
  NeuralNetwork actor;
  NeuralNetwork critic;
 
  while (true) {
    // NN COMPUTE - rewards and reset included in the function
    sim.programSetup();
 
    bot.trainingNetwork(actor, critic, 5000, 0.99, 0.015, 1.05, 1e-4);
  }
 
  return 0;
}
\end{minted}
\section*{Score Checker - Devices}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/score_checker/include/devices.h)
 
// library for devices
#include "include/libraries.h"
 
// MAIN BOT
Robot *score_checker = new Robot();
 
// EMITTER AND RECEIVER
Emitter *emit1 = score_checker->getEmitter("emit1");
Receiver *receiv1 = score_checker->getReceiver("receiv1");
 
// CAMERAS
// cameras for moveable goals
Camera *moveGoal1 = score_checker->getCamera("moveGoal1");
Camera *moveGoal2 = score_checker->getCamera("moveGoal2");
Camera *moveGoal3 = score_checker->getCamera("moveGoal3");
Camera *moveGoal4 = score_checker->getCamera("moveGoal4");
Camera *moveGoal5 = score_checker->getCamera("moveGoal5");
 
// CONNECTORS
// connectors for cameras
Connector *connect1 = score_checker->getConnector("connect1");
Connector *connect2 = score_checker->getConnector("connect2");
Connector *connect3 = score_checker->getConnector("connect3");
Connector *connect4 = score_checker->getConnector("connect4");
Connector *connect5 = score_checker->getConnector("connect5");
\end{minted}
\section*{Score Checker - Libraries}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/score_checker/include/libraries.h)
 
// WEBOTS
// libraries
#include <webots/Camera.hpp>
#include <webots/Connector.hpp>
#include <webots/Emitter.hpp>
#include <webots/Receiver.hpp>
#include <webots/Robot.hpp>
 
#define TIME_STEP 64
 
using namespace webots;
 
// OTHER
// libraries
#include <iostream>
#include <cstring>
 
using namespace std;
\end{minted}
\section*{Score Checker - Robot Functions}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/score_checker/include/robotFunctions.cpp)
 
// library for sim functions
#include "include/simFunctions.cpp"
 
// create the sim class
Sim sim;
 
class Bot{
private:
  double pixelCount = 0.0;
  int objectCount = 0;
 
public:
  int currentScore = 0;
  string cS = " ";
 
  // functions
  // grab recognized objects and calulate score
  int score() {
    // score the posts
    objectCount = moveGoal1->getRecognitionNumberOfObjects();
    calcScore(objectCount);
    objectCount = moveGoal2->getRecognitionNumberOfObjects();
    calcScore(objectCount);
    objectCount = moveGoal3->getRecognitionNumberOfObjects();
    calcScore(objectCount);
    objectCount = moveGoal4->getRecognitionNumberOfObjects();
    calcScore(objectCount);
    objectCount = moveGoal5->getRecognitionNumberOfObjects();
    calcScore(objectCount);
 
    cS = currentScore;
    sim.sendMessage(cS.c_str(), (int)strlen(cS.c_str()) + 1);
 
    return 0;
  }
 
  // add the score
  int calcScore(int postScore) {
    switch (postScore) {
      case 0:
        currentScore = currentScore + 0;
        break;
      case 1:
        currentScore = currentScore + 3;
        break;
      case 2:
        currentScore = currentScore + 4;
        break;
      case 3:
        currentScore = currentScore + 5;
        break;
      case 4:
        currentScore = currentScore + 6;
        break;
      case 5:
        currentScore = currentScore + 7;
        break;
      case 6:
        currentScore = currentScore + 8;
        break;
    }
 
    return 0;
  }
};
\end{minted}
\section*{Score Checker - Simulator Functions}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/score_checker/include/simFunctions.cpp)
 
#define CHANNEL_NUMBER 0.0
#define RANGE 999.9
 
class Sim{
private:
  const void* message1 = " ";
  int yes = 0;
 
public:
  // setup the bot
  int programSetup() {
    // CAMERAS
    // enable actual sensor
    moveGoal1->enable(TIME_STEP);
    moveGoal2->enable(TIME_STEP);
    moveGoal3->enable(TIME_STEP);
    moveGoal4->enable(TIME_STEP);
    moveGoal5->enable(TIME_STEP);
 
    // turn on recognition
    moveGoal1->recognitionEnable(TIME_STEP);
    moveGoal2->recognitionEnable(TIME_STEP);
    moveGoal3->recognitionEnable(TIME_STEP);
    moveGoal4->recognitionEnable(TIME_STEP);
    moveGoal5->recognitionEnable(TIME_STEP);
 
    // CONNECTORS
    connect1->enablePresence(TIME_STEP);
    connect2->enablePresence(TIME_STEP);
    connect3->enablePresence(TIME_STEP);
    connect4->enablePresence(TIME_STEP);
    connect5->enablePresence(TIME_STEP);
 
    // EMITTER AND RECEIVER
    receiv1->enable(TIME_STEP);
    receiv1->setChannel(CHANNEL_NUMBER);
    emit1->setChannel(CHANNEL_NUMBER);
    emit1->setRange(RANGE);
 
    return 0;
  }
 
  // delay the program
  int delay (double time, const char* unit) {
    if (unit == "msec") {
      time = time * 0.001;
    }
    float current_time_1 = float(score_checker->getTime());
    float current_time_2= float(score_checker->getTime());
    do {
      current_time_2 = float(score_checker->getTime());
      score_checker->step(1);
    } while(current_time_2 < (current_time_1 + time));
 
    return 0;
  }
 
  // send a message through the radio
  int sendMessage(const void* data, int size) {
    emit1->send(data, size);
    //cout << "SCORE: sending message" << endl;
 
    return 0;
  }
 
  // check for a message through the radio
  int receive() {
    if (receiv1->getQueueLength() != 0) {
      message1 = static_cast<const char *>(receiv1->getData());
      //cout << "SCORE: received: " << message1 << endl;
    } else {
      //cout << "SCORE: no messages received" << endl;
    }
 
    return 0;
  }
 
  // dismiss the message if called
  int dismissMessage() {
    receiv1->nextPacket();
 
    return 0;
  }
};
\end{minted}
\section*{Score Checker - Score Checker}
\begin{minted}[linenos, fontsize=\small]{cpp}
// (VEX_AI_SIM/score_checker/score_checker.cpp)
 
// libraries
#include "include/devices.h"
#include "include/robotFunctions.cpp"
 
// main program
int main() {
  cout << "program started" << endl;
  Bot bot;
  sim.programSetup();
  bool sending;
 
  while (true) {
    if (score_checker->getTime() >= 0) {
      sending = true;
      while (sending == true) {
        bot.score();
        bot.currentScore = 0;
        sim.delay(32, "msec");
      }
    }
  }
}
\end{minted}